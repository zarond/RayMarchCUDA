# Raymarching Cubemap with CUDA

На основе алгоритма Ray Marching (шагания по лучу) создана программа, загружающая сцену, описываемую файлами формата EXR, способными хранить значения пикселей в формате 32-битных чисел с плавающей точкой, и проводящая трассировку луча с 8 отражениями, собирая информацию о точках пересечения. Файлы хранятся в папках RayMarchCUDA/images и RayMarchCUDA/images2. В изображениях с названиям в формате C***.exr хранятся данные о коэффициентах (цвете и отражательной способности). В изображениях с названиям в формате N***.exr хранятся данные о векторе нормали и глубине. Исходные сцены хранятся в файле CubeCam.blend. Программа работает в трех режимах. Программа принимает два аргумента командной строки. Первый аргумент число a = {1,2} - номер сцены, второй аргумент b = {1,2,3} - номер режима работы.

Первый режим – визуальный, в котором цвет генерируется на основе цвета текстуры и коэффициента отражательной способности, кодирующегося в альфа-канале текстуры. В этом режиме во время прохода луча сохраняется информация о цвете в точке и коэффициенте отражения. После выполнения трассировки эта информация используется в алгоритме, который вычисляет итоговый цвет пикселя, обходя информацию в обратном направлении.

Второй режим отличается способом извлечения информации при трассировке. В этом режиме симулируется акустика. В качестве информации, описывающей акустические свойства материала, могут использоваться коэффициенты отражения для 4 диапазонов частот. Для каждого дошедшего до источника луча получаем четыре коэффициента отражения (полученные через перемножение сэмплов коэффициентов во всех точках отражений на пути луча) и длину луча. На каждом этапе проверяется пересечение с источником-сферой. Луч возвращает ненулевое значение только если произошло пересечение с источником. Информация о пересечении луча с источником отображается на экране, в дополнительный массив из float4 для каждого луча записывается информация о 4 коэффициентах частот, направлении луча и расстоянии до источника, упакованная в два значения float4.

Третий режим отличается от второго способом запуска лучей: в нем лучи испускаются во все направления, и визуализация проходит в виде 6 квадратных изображений, соответствующих граням куба. В текущей реализации лучи пускаются равномерно по поверхности куба, что облегчает визуализацию. В итоге визуализация результатов не важна, вследствие чего необходимо перейти на математически более верный выбор направлений для луча, распределив их равномерно по поверхности сферы, например, с помощью алгоритма наложения решетки Фибоначчи.

Временная сложность алгоритма регулируется с помощью ограничения на минимальный MIP-уровень и на количество итераций в алгоритме шагания по лучу. Можно настраивать точность в отдельности для каждого отражения, уменьшая сложность для более поздних отражений.

На Рис. 1 - 5 показаны примеры работы программы.

![](https://github.com/zarond/RayMarchCUDA/pictures/fig1.png)

Рис. 1 Сцена №1. Видны недостатки алгоритма описания сцены с помощью карт высот

![](https://github.com/zarond/RayMarchCUDA/pictures/fig2.png)

Рис. 2 Сцена №1. Видны отражения луча от поверхностей

![](https://github.com/zarond/RayMarchCUDA/pictures/fig3.png)

Рис. 3 Сцена №2 с зеркальными стенами. Видны множественные отражения

![](https://github.com/zarond/RayMarchCUDA/pictures/fig4.png)

Рис. 4 Визуализация режима работы №2. Белые точки - лучи, пересекающиеся с источником. В центре видны отражения от объекта-сферы в сцене.

![](https://github.com/zarond/RayMarchCUDA/pictures/fig5.png)

Рис. 5 Панорамная визуализация режима работы №3

Примерное время работы алгоритма для сцены с изображениями размером 1024×1024 и количеством отражений, равным восьми:
- Для первого режима с размером экрана 1920×1080: 13 – 24 мс.
- Для второго режима с размером экрана 1920×1080: 16 – 20 мс.
- Для третьего режима с количеством лучей 512×512 x 6: 29 мс.


Результаты алгоритма трассировки лучей используются следующим образом. По значениям четырех коэффициентов для каждого направления строится ядро свертки в частотном диапазоне, к которой применяется свертка функции HRTF для данного направления первичного луча. На последнем этапе все полученные ядра свертки редуцируются в выходную стерео-свертку, применяющуюся к звуку источника. Операции по применению функций HRTF также можно ускорить с помощью GPU. Данные преобразования не реализованы в моем алгоритме, но находятся в планах по дальнейшей разработке. 